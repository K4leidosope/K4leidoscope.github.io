{"meta":{"title":"碎片","subtitle":"","description":"","author":"Kaleidoscope","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2025-10-21T04:07:33.000Z","updated":"2025-10-21T04:07:50.820Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-10-21T04:07:29.000Z","updated":"2025-10-21T04:07:57.857Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"模板整理","slug":"模板整理","date":"2025-10-21T09:20:38.000Z","updated":"2025-10-22T01:04:31.601Z","comments":true,"path":"2025/10/21/模板整理/","permalink":"http://example.com/2025/10/21/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/","excerpt":"","text":"高精度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class INT &#123;public: int a[M]; INT() &#123; memset(a, 0, sizeof(a)); &#125; void clear() &#123; memset(a, 0, sizeof(a)); &#125; INT(int x) &#123; clear(); while (x) &#123; a[++a[0]] = x % 10; x /= 10; &#125; while (a[a[0]] == 0 &amp;&amp; a[0]) a[0]--; &#125; INT &amp;operator=(int x) &#123; clear(); while (x) &#123; a[++a[0]] = x % 10; x /= 10; &#125; while (a[a[0]] == 0 &amp;&amp; a[0]) a[0]--; return *this; &#125; short cmp(const INT &amp;x) &#123; if (a[0] &gt; x.a[0]) return 1; if (a[0] &lt; x.a[0]) return -1; for (register int i = a[0]; i &gt;= 1; i--) &#123; if (a[i] &gt; x.a[i]) return 1; if (a[i] &lt; x.a[i]) return -1; &#125; return 0; &#125; bool operator&gt;(const INT &amp;x) &#123; return cmp(x) == 1; &#125; bool operator==(const INT &amp;x) &#123; return cmp(x) == 0; &#125; bool operator&lt;(const INT &amp;x) &#123; return cmp(x) == -1; &#125; bool operator&gt;=(const INT &amp;x) &#123; return !(*this &lt; x); &#125; bool operator&lt;=(const INT &amp;x) &#123; return !(*this &gt; x); &#125; INT operator-(const INT &amp;x) &#123; INT a = *this, c; c.a[0] = a.a[0] &gt; x.a[0] ? a.a[0] : x.a[0]; for (register int i = 1; i &lt;= c.a[0]; i++) &#123; c.a[i] += a.a[i] - x.a[i]; if (c.a[i] &lt; 0) &#123; c.a[i] += 10; a.a[i + 1]--; &#125; &#125; while (c.a[c.a[0]] == 0 &amp;&amp; c.a[0]) c.a[0]--; return c; &#125; INT operator*(const INT &amp;x) &#123; INT c; for (register int i = 1; i &lt;= a[0]; i++) &#123; for (register int j = 1; j &lt;= x.a[0]; j++) &#123; c.a[i + j - 1] += a[i] * x.a[j]; &#125; &#125; c.a[0] = a[0] + x.a[0]; for (register int i = 1; i &lt;= c.a[0]; i++) &#123; if (c.a[i] &gt;= 10) &#123; c.a[i + 1] += c.a[i] / 10; c.a[i] %= 10; &#125; &#125; while (c.a[c.a[0]] == 0 &amp;&amp; c.a[0] &gt; 0) c.a[0]--; return c; &#125; INT operator/(const int &amp;x) &#123; INT c; int t = 0, s = 0; bool flag = 1; for (register int i = a[0]; i &gt;= 1; i--) &#123; t = s * 10 + a[i]; if (t / x &gt; 0 || t == 0) &#123; c.a[++c.a[0]] = t / x; s = t % x; flag = 0; &#125; else &#123; s = t; if (!flag) c.a[++c.a[0]] = 0; &#125; &#125; reverse(c.a + 1, c.a + c.a[0] + 1); return c; &#125;&#125;;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"构思","slug":"狗屎","date":"2025-10-21T05:44:42.000Z","updated":"2025-10-22T01:04:38.142Z","comments":true,"path":"2025/10/21/狗屎/","permalink":"http://example.com/2025/10/21/%E7%8B%97%E5%B1%8E/","excerpt":"hexo的数学渲染Bug太多了 MD和Mathjax的双重渲染会出很多错误","text":"hexo的数学渲染Bug太多了 MD和Mathjax的双重渲染会出很多错误 网上的解决方法又和主题不兼容 最后乱猜出一个方案： 1\\&#123; \\&#125; \\_ \\$ (无法正常显示) 替换成： 1\\\\&#123; \\\\&#125; \\\\_ \\\\$ （可以正常显示） 虽不知为何可以，可这确实能让一坨Bug较为正常地运行 似乎可以从中窥见内部代码有多么构思了","categories":[{"name":"shit","slug":"shit","permalink":"http://example.com/categories/shit/"}],"tags":[]},{"title":"练习#1-P2672","slug":"练习-1-P2672","date":"2025-10-20T12:50:12.000Z","updated":"2025-10-22T01:04:55.398Z","comments":true,"path":"2025/10/20/练习-1-P2672/","permalink":"http://example.com/2025/10/20/%E7%BB%83%E4%B9%A0-1-P2672/","excerpt":"Link 贪心策略证明： 总疲劳值=选取的住户疲劳值之和+最远端路程疲劳值 按住户疲劳值排序，选前X的住户得到方案I 由最远端路程疲劳值的单调性知：最远端位置小于I的最远位置对应方案总疲劳值小于I的总疲劳值","text":"Link 贪心策略证明： 总疲劳值=选取的住户疲劳值之和+最远端路程疲劳值 按住户疲劳值排序，选前X的住户得到方案I 由最远端路程疲劳值的单调性知：最远端位置小于I的最远位置对应方案总疲劳值小于I的总疲劳值 那么疲劳值最大的选法，其最远端位置必然大于等于I的最远端位置。对于最远端位置大于I的选法，剩余的X-1个待选位置需最大化，即取住户疲劳值前X-1项，此时这些选法前X-1项固定，只需最后一项最大化，取 $$max(s[i]+2*d[i])$$ 最后只需比较该取法和方案I，取疲劳值大的那个即可 PS：自然语言还是太啰嗦了，下次尝试用符号来刻画 上面最大化对应集合表述应是：$$max\\{S\\}=max\\{A \\cap B\\}=max\\{A \\cap \\{max\\{B\\}\\}\\}$$，即将子部分最大而化简整个方案集合（给这种靠感觉的变化打个正确性补丁） 为什么想了很久： 在简化，抽象化的过程中，抛弃了题目的特殊性，导致方向错误 N种数列：$\\{a_{i,n}\\},1\\le i \\le N$ 不可能在$O(nlogn)$内求出$$max\\{\\ \\sum_{1\\le i_1 \\le …i_N \\le len} a_{sub \\_ index(i),i_1} \\}$$ 这题的特殊性在于附加权的单调性，而不是数列的重复 启发： 注意思维的跳跃性 深搜，碰壁，返回所需的时间太久了 跳跃性的转换思维，广搜，才容易迅速找到正解","categories":[{"name":"ACM_P","slug":"ACM-P","permalink":"http://example.com/categories/ACM-P/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"http://example.com/tags/Luogu/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"}]}],"categories":[{"name":"shit","slug":"shit","permalink":"http://example.com/categories/shit/"},{"name":"ACM_P","slug":"ACM-P","permalink":"http://example.com/categories/ACM-P/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://example.com/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"Luogu","slug":"Luogu","permalink":"http://example.com/tags/Luogu/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"}]}